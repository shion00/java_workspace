
오늘 수업 주제 : 패키지와 임포트
-----------------------------------------------------------

개발시 원본소스와 컴파일 결과물은 반드시 구분해서 관리해야 한다.
이때 원본소스는 src, 컴파일 결과물은 bin or classes라는 이름의 폴더를 많이 사용한다.

이제 src 에 .java 소스를 저장하되, 주의할것은 원본소스의 패키지는 개발자가 직접 만들어야 하고
컴파일 결과물의 패키지는 자동으로 만들어 집니다.

Dog.java 라는 클래스를 만들되, 패키지를 선언하셔야, 컴파일시 패키지가 
자동으로 만들어 집니다.

이제 이 클래스를 컴파일해서, bin 안에 자동으로 만들어 지도록 하겠다.
cmd 에서 cd로 원본소스가 있는 곳으로 먼저 가야 합니다.
명령어는 javac -d 경로 Dog.java 입니다.

경로는 
D:\workspace\java_workspace\project1022\bin 이다.

이제 bin 으로 가서 animal 이 자동으로 만들어 졌는지 확인한다.
개발시 일일이 콘솔에서 컴파일 하기엔 효율성이 떨어지므로 툴을 이용하여 이 작업을 진행한다.
editplus의 툴에 등록, 참고로 매 프로젝트마다 해야 한다.

컴파일환경을 등록한 후 꼭 사용할 그룹으로 선택을 바꿔야 한다.

서로 다른 경로에 있는 클래스를 사용하는 법
use라는 패키지에 UseDog이라는 클래스를 정의합니다.

1) 같은 패키지에 있어야 한다.
2) 실행부가 있는 원본소스를 컴파일하면, 원본소스도 컴파일되고 인스턴스를 생성하는 원본소스도 함께 컴파일된다.
3) 실행부가 있는 원본소스를 컴파일하기 위해서는 인스턴스의 원본소스도 가능하고 바이트코드파일도 가능하다.
   인스턴스의 원본소스와 컴파일하면 바이트 코드파일이 컴파일되고, 바디트코드파일과 컴파일하면 바이트코드가 
   생성되지 않는다. 

package 는 컴파일할때 페키지 생성 
import 패키지가 다른 클래스에서 사용하고자 하는 클래스의 바이트 코드
public class로 컴파일된 바이트 코드
--------------------------------------------------------------
접근 제한자
 : 클래스내에 작성되는 변수는 지금까지 색상, 가격 이런 기본적인 연습용 데이터였지만
   사실상 자바 개발자가 현업에서 다루는 업무는 주로 계좌, 고객정보 등 상당히 민감한 
   데이터를 다룹니다. 따라서 클래스내에 있는 변수는 데이터이므로 보호받아야 한다.
   자바에서는 이렇게 데이터를 보호할 수 있는 보안 장치를 지원해 주는데, 이를 가리켜
   접근제한자 라고 한다.

접근제한자의 종류
  약한것 순으로 나열하자면

  public(보안도 아님 그냥 공개임)
  protected(상속관계이 있는 부모자식 클래스끼리만 접근가능)
  default(같은 패키지 안에 있는 클래스끼리만 접근 가능, 상속받았다 할지라도 같
          은 패키지가 아니라면 접근 못함)
  private(같은 클래스내의 멤버끼리만 접근 가능)
         예) 멤버메서드가 멤버변수에 접근

  결국 보안 순서는 이렇게 된다.
  public < protected < deault < private

 이렇게 적어드리면, 마치 개발할때 개발자가 보안을 철저히 따져가면서 클래스를 만들거 같지만
 사실 private를 많이 쓰게된다.
---------------------------------------------------------------
실습해보자!
고객의 "계좌" 라는 주제를 가지고 클래스를 정의해본다.



----------------------------------------------


접근제한자 수업 정리

접근제한자는 자바에서 보안을 처리하기 위한 방법을 제공한다.
여기서 특히 prviate 의 활용도가 상당히 높다.
사실상 클래스내엣 선언되는 변수는 모두 private 하는게 많아요
왜냐면 아까 얘기했듯이 데이터는 보호되어야 하니깐요, 리모콘처럼 내부 장치는 덮어놓아야 한다.
이 내부장치를 외부에서 제어하려면 접근 "방법"을 제공해주어야 하는데 그게 바로 getter/setter
메서드이다. 그리고 데이터를 private 보호하고, 오지 getter/setter 를 통해서 데이터를 
간접 제어할 수 있도록 클래스를 정의하는 기법을 가리켜 객체지향 OOP에서는 은닉화()캡슐화 라고 한다.


//아래의 변수는 아무도 직접 접근 못하게 일부러 보안을 강화 했음.
private int balance=100000;
그런데, 막상 setter/getter 를 이용해서 외부의 침입자가 제어할 수 있다면 


acc.setBalance(0); //나쁜짓

public void setBalance(){

	if(balance>0){
		this.balance=balance;
	}
	
}




-------------------------------------------------

"모든 사물은 단독으로 존재할 수 없다."

객체지향 언어인 자바에서는 모든 사물을 단독으로 존재할 수 없다는 관점을 2가지 경우로 
나누어 생각한다.

1) is a 관계 : ex) Duck is a Bird "오리는 새다"
	          상속관계를 나타내는 말이다.

2) has a 관계 : 자동차는 바퀴를 가지고 있다. Car has a Wheel
	       부픔관계를 나타내는 말입니다.
               부품관계란, 특정 객체가 다른 객체를 멤버변수로 보유한 경우를 말한다.



cf ) innerClass 랑 has a 랑은 느낌이 달라요 
innerClass는 재사용성이 없는 클래스를 .java라는 파일로 두지 않고
클래스내에 빨리 작성하고자 할때, 사용하고
has a 관계로 존재하는 클래스들은 .java 파일로 저장해 두고 , 재사용성이 높은 경우 사용해요
그니깐 목적이 좀 틀립니다..
클래스가 클래스 안에 들어갓다고 해서 다 같은게 아닙니당~


문제4번)



강사님 혹시 만약에 Taxi에서 부모인 Car의 변수값을 바꾸면 Bus에서도 바뀐 값이 적용되나요??
아니다.
인스턴스가 바뀐것이라서 클래스 원본이 바뀐게 아니기 때문
static을 부모가 가지고 있고, 이것을 공유하면 다같이 바뀌겠지만
new Taxi(), new B



부모{ int a = 3;}
자식 extends 부모{ int a = 5;}
메인메소드{
 자식 s = new 자식();
} 

s.a 는 5일텐데
메인메소드안에서 부모의 int a값에 접근하는 방법은 없는건가요?



자식의 생성자 메서드 안에 super()가 있어 부모생성자를 호출하는건 이해가 가는데
new 연산자 없이  



